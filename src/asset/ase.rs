use std::{fmt, path::PathBuf};

use asefile::AsepriteFile;
use bevy::reflect::TypeUuid;
use bevy::utils::HashMap;

/// Handle type for ase assets.
///
/// The [Loader] processes [AseAsset] instances and stores their data
/// in bevy's Assets resources (as Texture, [Animation], etc).
///
/// # Examples
///
/// ```
/// use bevy::prelude::*;
/// use bevy_ase::loader::AseAsset;
///
/// // Convert an untyped handle into an AseAsset handle.
/// pub fn to_typed(handle: HandleUntyped) -> Handle<AseAsset> {
///    handle.clone().typed::<AseAsset>()
/// }
/// ```
#[derive(Debug, TypeUuid)]
#[uuid = "053511cb-7843-47a3-b5b6-c3279dc7cf6f"]
pub struct AseAsset {
    pub(crate) data: AseData,
    pub(crate) name: PathBuf,
}
impl AseAsset {
    /// Returns a reference to the asset's file data, if this asset has not yet been processed.
    pub fn file(&self) -> Option<&AsepriteFile> {
        if let AseData::Loaded(file) = &self.data {
            Some(file)
        } else {
            None
        }
    }
}

/// Contains Aseprite file data before processing.
///
/// During processing, Loaded data is moved into other asset types.
/// Afterward, the Loaded instances are replaced with Processed instances.
#[derive(Debug)]
pub(crate) enum AseData {
    Loaded(AsepriteFile),
    Processed,
}

/// Unique identifier for an Aseprite file.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub struct AseId(u32);
impl AseId {
    /// Creates a new AseId over a u32 value.
    /// During asset loading, AseId values are generated by wrapping the file index.
    pub fn new(inner: u32) -> Self {
        Self(inner)
    }
    /// Returns a reference to the AseId's underlying u32 value.
    pub fn inner(&self) -> &u32 {
        &self.0
    }
}
impl fmt::Display for AseId {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "AseId({})", self.0)
    }
}

pub(crate) struct AsepriteFileWithId {
    pub(crate) id: AseId,
    pub(crate) path: PathBuf,
    pub(crate) file: AsepriteFile,
}

pub(crate) struct AsesById(HashMap<AseId, AsepriteFileWithId>);
impl AsesById {
    pub fn iter(&self) -> std::collections::hash_map::Iter<'_, AseId, AsepriteFileWithId> {
        self.0.iter()
    }
}
impl From<Vec<(PathBuf, AsepriteFile)>> for AsesById {
    fn from(vec: Vec<(PathBuf, AsepriteFile)>) -> Self {
        Self(
            vec.into_iter()
                .enumerate()
                .map(|(idx, (path, file))| {
                    let id = AseId::new(idx as u32);
                    let value = AsepriteFileWithId { id, path, file };
                    (id, value)
                })
                .collect(),
        )
    }
}
